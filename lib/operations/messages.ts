/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "ms-rest-js";
import * as Models from "../models";
import * as Mappers from "../models/mappers";
import { ElmahioAPIContext } from "../elmahioAPIContext";

const WebResource = msRest.WebResource;

/** Class representing a Messages. */
export class Messages {
  private readonly client: ElmahioAPIContext;
  /**
   * Create a Messages.
   * @param {ElmahioAPIContext} client Reference to the service client.
   */
  constructor(client: ElmahioAPIContext) {
    this.client = client;
  }

  /**
   * @summary Fetch messages from a log.
   *
   * @param {string} logId The ID of the log containing the messages.
   *
   * @param {MessagesGetAllOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getAllWithHttpOperationResponse(logId: string, options?: Models.MessagesGetAllOptionalParams): Promise<msRest.HttpOperationResponse<Models.MessagesResult>> {
    let client = this.client;
    let pageIndex = (options && options.pageIndex !== undefined) ? options.pageIndex : undefined;
    let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : undefined;
    let query = (options && options.query !== undefined) ? options.query : undefined;
    let from = (options && options.from !== undefined) ? options.from : undefined;
    let to = (options && options.to !== undefined) ? options.to : undefined;
    let includeHeaders = (options && options.includeHeaders !== undefined) ? options.includeHeaders : undefined;
    // Validate
    try {
      if (logId === null || logId === undefined || typeof logId.valueOf() !== 'string') {
        throw new Error('logId cannot be null or undefined and it must be of type string.');
      }
      if (pageIndex !== null && pageIndex !== undefined && typeof pageIndex !== 'number') {
        throw new Error('pageIndex must be of type number.');
      }
      if (pageSize !== null && pageSize !== undefined && typeof pageSize !== 'number') {
        throw new Error('pageSize must be of type number.');
      }
      if (query !== null && query !== undefined && typeof query.valueOf() !== 'string') {
        throw new Error('query must be of type string.');
      }
      if (from && !(from instanceof Date ||
          (typeof (from as string).valueOf() === 'string' && !isNaN(Date.parse(from as string))))) {
            throw new Error('from must be of type date.');
          }
      if (to && !(to instanceof Date ||
          (typeof (to as string).valueOf() === 'string' && !isNaN(Date.parse(to as string))))) {
            throw new Error('to must be of type date.');
          }
      if (includeHeaders !== null && includeHeaders !== undefined && typeof includeHeaders !== 'boolean') {
        throw new Error('includeHeaders must be of type boolean.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          logId,
          pageIndex,
          pageSize,
          query,
          from,
          to,
          includeHeaders
        },
        options);
      operationRes = await client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.client.baseUri,
          path: "v3/messages/{logId}",
          urlParameters: [
            {
              parameterName: "logId",
              mapper: {
                required: true,
                serializedName: "logId",
                type: {
                  name: "String"
                }
              }
            }
          ],
          queryParameters: [
            {
              parameterName: "pageIndex",
              mapper: {
                serializedName: "pageIndex",
                type: {
                  name: "Number"
                }
              }
            },
            {
              parameterName: "pageSize",
              mapper: {
                serializedName: "pageSize",
                type: {
                  name: "Number"
                }
              }
            },
            {
              parameterName: "query",
              mapper: {
                serializedName: "query",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterName: "from",
              mapper: {
                serializedName: "from",
                type: {
                  name: "DateTime"
                }
              }
            },
            {
              parameterName: "to",
              mapper: {
                serializedName: "to",
                type: {
                  name: "DateTime"
                }
              }
            },
            {
              parameterName: "includeHeaders",
              mapper: {
                serializedName: "includeHeaders",
                type: {
                  name: "Boolean"
                }
              }
            }
          ]
        });
      let statusCode = operationRes.status;
      if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 429) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = operationRes.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(operationRes);
        let parsedErrorResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            const resultMapper = Mappers.MessagesResult;
            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create a new message.
   *
   * @param {string} logId The ID of the log which should contain the new
   * message.
   *
   * @param {CreateMessage} message The message object to create.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createWithHttpOperationResponse(logId: string, message: Models.CreateMessage, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {
    let client = this.client;
    // Validate
    try {
      if (logId === null || logId === undefined || typeof logId.valueOf() !== 'string') {
        throw new Error('logId cannot be null or undefined and it must be of type string.');
      }
      if (message === null || message === undefined) {
        throw new Error('message cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          logId,
          message
        },
        options);
      operationRes = await client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "v3/messages/{logId}",
          urlParameters: [
            {
              parameterName: "logId",
              mapper: {
                required: true,
                serializedName: "logId",
                type: {
                  name: "String"
                }
              }
            }
          ],
          requestBodyMapper: Mappers.CreateMessage,
          requestBodyName: "message",
          contentType: "application/json; charset=utf-8"
        });
      let statusCode = operationRes.status;
      if (statusCode !== 200 && statusCode !== 201 && statusCode !== 400 && statusCode !== 401 && statusCode !== 403 && statusCode !== 404 && statusCode !== 413 && statusCode !== 429) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = operationRes.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(operationRes);
        let parsedErrorResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Deletes a list of messages by logid and query.
   *
   * @param {string} logId The ID of the log containing the message.
   *
   * @param {Search} search A search object containing query, time filters etc.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteAllWithHttpOperationResponse(logId: string, search: Models.Search, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {
    let client = this.client;
    // Validate
    try {
      if (logId === null || logId === undefined || typeof logId.valueOf() !== 'string') {
        throw new Error('logId cannot be null or undefined and it must be of type string.');
      }
      if (search === null || search === undefined) {
        throw new Error('search cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          logId,
          search
        },
        options);
      operationRes = await client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "DELETE",
          baseUrl: this.client.baseUri,
          path: "v3/messages/{logId}",
          urlParameters: [
            {
              parameterName: "logId",
              mapper: {
                required: true,
                serializedName: "logId",
                type: {
                  name: "String"
                }
              }
            }
          ],
          requestBodyMapper: Mappers.Search,
          requestBodyName: "search",
          contentType: "application/json; charset=utf-8"
        });
      let statusCode = operationRes.status;
      if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 429) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = operationRes.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(operationRes);
        let parsedErrorResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Fetch a message by its ID.
   *
   * @param {string} id The ID of the message to fetch.
   *
   * @param {string} logId The ID of the log containing the message.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getWithHttpOperationResponse(id: string, logId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.Message>> {
    let client = this.client;
    // Validate
    try {
      if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
        throw new Error('id cannot be null or undefined and it must be of type string.');
      }
      if (logId === null || logId === undefined || typeof logId.valueOf() !== 'string') {
        throw new Error('logId cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          id,
          logId
        },
        options);
      operationRes = await client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.client.baseUri,
          path: "v3/messages/{logId}/{id}",
          urlParameters: [
            {
              parameterName: "id",
              mapper: {
                required: true,
                serializedName: "id",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterName: "logId",
              mapper: {
                required: true,
                serializedName: "logId",
                type: {
                  name: "String"
                }
              }
            }
          ]
        });
      let statusCode = operationRes.status;
      if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 429) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = operationRes.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(operationRes);
        let parsedErrorResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            const resultMapper = Mappers.Message;
            operationRes.parsedBody = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete a message by its ID.
   *
   * @param {string} id The ID of the message to delete.
   *
   * @param {string} logId The ID of the log containing the message.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteMethodWithHttpOperationResponse(id: string, logId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {
    let client = this.client;
    // Validate
    try {
      if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
        throw new Error('id cannot be null or undefined and it must be of type string.');
      }
      if (logId === null || logId === undefined || typeof logId.valueOf() !== 'string') {
        throw new Error('logId cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          id,
          logId
        },
        options);
      operationRes = await client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "DELETE",
          baseUrl: this.client.baseUri,
          path: "v3/messages/{logId}/{id}",
          urlParameters: [
            {
              parameterName: "id",
              mapper: {
                required: true,
                serializedName: "id",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterName: "logId",
              mapper: {
                required: true,
                serializedName: "logId",
                type: {
                  name: "String"
                }
              }
            }
          ]
        });
      let statusCode = operationRes.status;
      if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 429) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = operationRes.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(operationRes);
        let parsedErrorResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Hide a message by its ID.
   *
   * @param {string} id The ID of the message to hide.
   *
   * @param {string} logId The ID of the log containing the message.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async hideWithHttpOperationResponse(id: string, logId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {
    let client = this.client;
    // Validate
    try {
      if (id === null || id === undefined || typeof id.valueOf() !== 'string') {
        throw new Error('id cannot be null or undefined and it must be of type string.');
      }
      if (logId === null || logId === undefined || typeof logId.valueOf() !== 'string') {
        throw new Error('logId cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          id,
          logId
        },
        options);
      operationRes = await client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "v3/messages/{logId}/{id}/_hide",
          urlParameters: [
            {
              parameterName: "id",
              mapper: {
                required: true,
                serializedName: "id",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterName: "logId",
              mapper: {
                required: true,
                serializedName: "logId",
                type: {
                  name: "String"
                }
              }
            }
          ]
        });
      let statusCode = operationRes.status;
      if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 429) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = operationRes.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(operationRes);
        let parsedErrorResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Fetch messages from a log.
   *
   * @param {string} logId The ID of the log containing the messages.
   *
   * @param {MessagesGetAllOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.MessagesResult} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.MessagesResult} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getAll(logId: string): Promise<Models.MessagesResult>;
  getAll(logId: string, options: Models.MessagesGetAllOptionalParams): Promise<Models.MessagesResult>;
  getAll(logId: string, callback: msRest.ServiceCallback<Models.MessagesResult>): void;
  getAll(logId: string, options: Models.MessagesGetAllOptionalParams, callback: msRest.ServiceCallback<Models.MessagesResult>): void;
  getAll(logId: string, options?: Models.MessagesGetAllOptionalParams, callback?: msRest.ServiceCallback<Models.MessagesResult>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.MessagesResult>;
    if (!callback) {
      return this.getAllWithHttpOperationResponse(logId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.MessagesResult);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getAllWithHttpOperationResponse(logId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.MessagesResult;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Create a new message.
   *
   * @param {string} logId The ID of the log which should contain the new
   * message.
   *
   * @param {CreateMessage} message The message object to create.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  create(logId: string, message: Models.CreateMessage): Promise<void>;
  create(logId: string, message: Models.CreateMessage, options: msRest.RequestOptionsBase): Promise<void>;
  create(logId: string, message: Models.CreateMessage, callback: msRest.ServiceCallback<void>): void;
  create(logId: string, message: Models.CreateMessage, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  create(logId: string, message: Models.CreateMessage, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.createWithHttpOperationResponse(logId, message, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createWithHttpOperationResponse(logId, message, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Deletes a list of messages by logid and query.
   *
   * @param {string} logId The ID of the log containing the message.
   *
   * @param {Search} search A search object containing query, time filters etc.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAll(logId: string, search: Models.Search): Promise<void>;
  deleteAll(logId: string, search: Models.Search, options: msRest.RequestOptionsBase): Promise<void>;
  deleteAll(logId: string, search: Models.Search, callback: msRest.ServiceCallback<void>): void;
  deleteAll(logId: string, search: Models.Search, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  deleteAll(logId: string, search: Models.Search, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.deleteAllWithHttpOperationResponse(logId, search, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteAllWithHttpOperationResponse(logId, search, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Fetch a message by its ID.
   *
   * @param {string} id The ID of the message to fetch.
   *
   * @param {string} logId The ID of the log containing the message.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.Message} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.Message} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  get(id: string, logId: string): Promise<Models.Message>;
  get(id: string, logId: string, options: msRest.RequestOptionsBase): Promise<Models.Message>;
  get(id: string, logId: string, callback: msRest.ServiceCallback<Models.Message>): void;
  get(id: string, logId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.Message>): void;
  get(id: string, logId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.Message>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.Message>;
    if (!callback) {
      return this.getWithHttpOperationResponse(id, logId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.Message);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getWithHttpOperationResponse(id, logId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.Message;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Delete a message by its ID.
   *
   * @param {string} id The ID of the message to delete.
   *
   * @param {string} logId The ID of the log containing the message.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(id: string, logId: string): Promise<void>;
  deleteMethod(id: string, logId: string, options: msRest.RequestOptionsBase): Promise<void>;
  deleteMethod(id: string, logId: string, callback: msRest.ServiceCallback<void>): void;
  deleteMethod(id: string, logId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  deleteMethod(id: string, logId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.deleteMethodWithHttpOperationResponse(id, logId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteMethodWithHttpOperationResponse(id, logId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Hide a message by its ID.
   *
   * @param {string} id The ID of the message to hide.
   *
   * @param {string} logId The ID of the log containing the message.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  hide(id: string, logId: string): Promise<void>;
  hide(id: string, logId: string, options: msRest.RequestOptionsBase): Promise<void>;
  hide(id: string, logId: string, callback: msRest.ServiceCallback<void>): void;
  hide(id: string, logId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  hide(id: string, logId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.hideWithHttpOperationResponse(id, logId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.hideWithHttpOperationResponse(id, logId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

}
